<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>ROTM Admin Dashboard</title>
<script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
<style>
body { font-family: Arial; background:#111; color:#fff; padding:20px; max-width:1200px; margin:auto; }
h1, h2 { text-align:center; }
table { width:100%; border-collapse:collapse; margin-top:20px; }
th, td { border:1px solid #555; padding:10px; text-align:center; }
th { background:#333; }
#rankingTable tbody tr { transition: all 0.7s ease-in-out; position: relative; }
tr.top1 { background:#d4af37; color:#111; font-weight:bold; }
tr.top2 { background:#c0c0c0; color:#111; font-weight:bold; }
tr.top3 { background:#cd7f32; color:#111; font-weight:bold; }
button { margin-top:20px; padding:10px 20px; font-size:16px; cursor:pointer; }
.tab-buttons { text-align:center; margin-top:20px; }
.tab-buttons button { margin:0 5px; }
#resetButton { background-color: #c0392b; color: white; border: none; }
#exportCsvBtn { background-color: #2ecc71; color: white; border: none; }
#updateVideosBtn { background-color: #3498db; color: white; border: none; } /* New button style */
.tab { display:none; }
.tab.active { display:block; }
#authStatus { text-align:center; margin-top:20px; font-size:18px; font-weight:bold; }
#loginBtn { display:block; margin:20px auto; padding:10px 20px; font-size:16px; cursor:pointer; }
#pieChartContainer { margin-top: 30px; padding: 20px; background: #222; border-radius: 5px; }
@keyframes rankMove { 0% { transform: translateY(-30px); opacity:0.5; } 50% { transform: translateY(15px); opacity:1; } 100% { transform: translateY(0); opacity:1; } }
.rank-move { animation: rankMove 0.8s ease-in-out; }
</style>
</head>
<body>
<h1>ROTM Admin Dashboard</h1>
<div id="authStatus">Checking authentication...</div>
<button id="loginBtn" style="display:none;">Login with Google</button>

<div id="adminContent" style="display:none;">
    <div class="tab-buttons">
      <button id="scoresTabBtn">Scores</button>
      <button id="votesTabBtn">Detailed Votes & Stats</button>
      <button id="updateVideosBtn">Update Videos from links.json</button>
      <button id="resetButton">Reset All Votes</button>
    </div>

    <div id="scoresTab" class="tab active">
      <h2>Video Rankings</h2>
      <table id="rankingTable">
        <thead>
          <tr>
            <th>Rank</th>
            <th>Video Title</th>
            <th>Reddit Upvotes</th>
            <th>Upvote Points</th>
            <th>Vote Points</th>
            <th>Total Score</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <div id="votesTab" class="tab">
      <h2>Detailed Votes</h2>
      <button id="exportCsvBtn">Export Votes to CSV</button>
      <table id="votesTable">
        <thead>
          <tr>
            <th>User ID</th>
            <th>Rank 1</th>
            <th>Rank 2</th>
            <th>Rank 3</th>
            <th>Timestamp</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      
      <div id="pieChartContainer">
        <h2>Votes Distribution (Rank 1/2/3)</h2>
        <div id="rank1PieChart" style="width: 100%; height: 500px;"></div>
      </div>

    </div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
import { getFirestore, collection, onSnapshot, getDocs, deleteDoc, doc, writeBatch } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";
import { getAuth, GoogleAuthProvider, signInWithPopup, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";

const firebaseConfig = {
    apiKey: "AIzaSyDChk83uv5LqXHemAziEHO3YAqEROHjIbo",
    authDomain: "rotm-2a088.firebaseapp.com",
    projectId: "rotm-2a088"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const auth = getAuth(app);
const provider = new GoogleAuthProvider();

// ADMIN EMAILS
const adminEmails = ["vpsjdon@gmail.com"];

const authStatus = document.getElementById("authStatus");
const adminContent = document.getElementById("adminContent");
const loginBtn = document.getElementById("loginBtn");
const updateVideosBtn = document.getElementById("updateVideosBtn"); 

// --- Authentication ---
loginBtn.addEventListener("click", async () => {
    try { await signInWithPopup(auth, provider); } 
    catch (e) { console.error(e); authStatus.innerText = "Login failed. Try again."; }
});

onAuthStateChanged(auth, (user) => {
    if(!user){ authStatus.innerText="Please log in to continue."; loginBtn.style.display="block"; adminContent.style.display="none"; }
    else if(adminEmails.includes(user.email)){ authStatus.innerText="Signed in as "+user.email; loginBtn.style.display="none"; adminContent.style.display="block"; initDashboard(); }
    else { authStatus.innerText="Access denied for "+user.email; loginBtn.style.display="none"; adminContent.style.display="none"; signOut(auth); }
});

// --- Dashboard ---
let videosData = {};
let votesData = [];
let videosLoaded = false;
let votesLoaded = false;
const videosCol = collection(db,"videos");
const votesCol = collection(db,"votes");

function initDashboard(){
    const scoresTabBtn = document.getElementById("scoresTabBtn");
    const votesTabBtn = document.getElementById("votesTabBtn");
    const scoresTab = document.getElementById("scoresTab");
    const votesTab = document.getElementById("votesTab");
    const resetButton = document.getElementById("resetButton");
    const exportCsvBtn = document.getElementById("exportCsvBtn");

    scoresTabBtn.addEventListener("click",()=>{ scoresTab.classList.add("active"); votesTab.classList.remove("active"); triggerRankingAnimation(); });
    votesTabBtn.addEventListener("click",()=>{ votesTab.classList.add("active"); scoresTab.classList.remove("active"); drawVotesChart(); });
    updateVideosBtn.addEventListener("click", updateVideosFromJSON);

    onSnapshot(videosCol,snapshot=>{
        videosData={};
        snapshot.docs.forEach(doc=>{ videosData[doc.id]={...doc.data(), votePoints:0, upvotePoints:0, totalScore:0, rank1Votes:0, rank2Votes:0, rank3Votes:0 }; });
        videosLoaded=true; if(votesLoaded) calculateScores();
    });

    onSnapshot(votesCol,snapshot=>{
        votesData=snapshot.docs.map(doc=>({id:doc.id,...doc.data()}));
        votesLoaded=true; if(videosLoaded) calculateScores(); renderVotes();
    });

    function calculateScores(){
        if(!videosLoaded || !votesLoaded || Object.keys(videosData).length===0) return;
        Object.values(videosData).forEach(v=>{ v.votePoints=0; v.upvotePoints=0; v.totalScore=0; v.rank1Votes=0; v.rank2Votes=0; v.rank3Votes=0; });

        votesData.forEach(vote=>{
            if(vote.rank1 && videosData[vote.rank1]) videosData[vote.rank1].votePoints+=100, videosData[vote.rank1].rank1Votes+=1;
            if(vote.rank2 && videosData[vote.rank2]) videosData[vote.rank2].votePoints+=50, videosData[vote.rank2].rank2Votes+=1;
            if(vote.rank3 && videosData[vote.rank3]) videosData[vote.rank3].votePoints+=25, videosData[vote.rank3].rank3Votes+=1;
        });

        const sortedByUpvotes=Object.entries(videosData).sort((a,b)=>b[1].upvotes-a[1].upvotes);
        const step=10; sortedByUpvotes.forEach(([id,v],i)=>{ videosData[id].upvotePoints=step*(sortedByUpvotes.length-i); });

        Object.values(videosData).forEach(v=>v.totalScore=v.votePoints+v.upvotePoints);
        renderRanking(); drawVotesChart();
    }

    function renderRanking(){
        const tbody=document.querySelector("#rankingTable tbody");
        const existingRows=Array.from(tbody.querySelectorAll('tr')).reduce((acc,tr)=>{ acc[tr.dataset.videoId]=tr; return acc; },{});
        tbody.innerHTML="";
        const sorted=Object.entries(videosData).sort((a,b)=>b[1].totalScore-a[1].totalScore);
        sorted.forEach(([id,v],i)=>{
            let tr=existingRows[id]||document.createElement("tr");
            tr.dataset.videoId=id;
            tr.innerHTML=`<td>${i+1}</td><td>${v.title}</td><td>${v.upvotes||0}</td><td>${v.upvotePoints||0}</td><td>${v.votePoints||0}</td><td>${v.totalScore||0}</td>`;
            tr.classList.remove("top1","top2","top3");
            if(i===0) tr.classList.add("top1"); else if(i===1) tr.classList.add("top2"); else if(i===2) tr.classList.add("top3");
            tbody.appendChild(tr);
        });
    }

    function renderVotes(){
        const tbody=document.querySelector("#votesTable tbody");
        tbody.innerHTML="";
        if(!votesData || votesData.length===0 || Object.keys(videosData).length===0) return;
        votesData.slice().sort((a,b)=>(b.timestamp?.seconds||0)-(a.timestamp?.seconds||0)).forEach(v=>{
            const tr=document.createElement("tr");
            const ts=v.timestamp?.seconds?new Date(v.timestamp.seconds*1000).toLocaleString():"";
            tr.innerHTML=`<td>${v.userId||""}</td><td>${v.rank1?videosData[v.rank1]?.title||v.rank1:""}</td><td>${v.rank2?videosData[v.rank2]?.title||v.rank2:""}</td><td>${v.rank3?videosData[v.rank3]?.title||v.rank3:""}</td><td>${ts}</td>`;
            tbody.appendChild(tr);
        });
    }

    resetButton.addEventListener('click',async()=>{
        if(!confirm("Delete ALL votes permanently?")) return;
        try{ const querySnapshot=await getDocs(votesCol); await Promise.all(querySnapshot.docs.map(doc=>deleteDoc(doc.ref))); alert("All votes reset successfully."); }
        catch(e){ console.error(e); alert("Failed to reset votes."); }
    });

    function triggerRankingAnimation(){
        const tbody=document.querySelector("#rankingTable tbody");
        tbody.querySelectorAll('tr').forEach(tr=>{ tr.classList.remove('rank-move'); void tr.offsetWidth; tr.classList.add('rank-move'); });
    }

    // --- Charts ---
    function drawVotesChart(){
        if(typeof google==='undefined'||!votesLoaded||Object.keys(videosData).length===0) return;
        const chartContainer=document.getElementById('rank1PieChart');
        const chartDataArray=[['Video Title','Rank 1','Rank 2','Rank 3']];
        Object.values(videosData).forEach(v=>{ chartDataArray.push([v.title,v.rank1Votes||0,v.rank2Votes||0,v.rank3Votes||0]); });
        const data=google.visualization.arrayToDataTable(chartDataArray);
        const options={ title:'Votes Distribution (Rank1/2/3) per Video', isStacked:true, backgroundColor:'#222', legend:{textStyle:{color:'#fff'}}, titleTextStyle:{color:'#fff', fontSize:16}, colors:['#d4af37','#c0c0c0','#cd7f32'], chartArea:{width:'70%',height:'70%'} };
        const chart=new google.visualization.BarChart(chartContainer); chart.draw(data,options);
    }
    google.charts.load('current',{'packages':['corechart']});

    // --- CSV export ---
    exportCsvBtn.addEventListener('click',()=>{
        if(votesData.length===0){ alert("No votes to export."); return; }
        const header=["User ID","Rank 1 (ID)","Rank 2 (ID)","Rank 3 (ID)","Rank 1 (Title)","Rank 2 (Title)","Rank 3 (Title)","Timestamp"];
        const rows=votesData.map(v=>{
            const ts=v.timestamp?.seconds?new Date(v.timestamp.seconds*1000).toLocaleString():"";
            const r1Title=videosData[v.rank1]?.title||"", r2Title=videosData[v.rank2]?.title||"", r3Title=videosData[v.rank3]?.title||"";
            return [`"${v.userId||''}"`,`"${v.rank1||''}"`,`"${v.rank2||''}"`,`"${v.rank3||''}"`,`"${r1Title}"`,`"${r2Title}"`,`"${r3Title}"`,`"${ts}"`].join(',');
        });
        const csvContent=[header.join(','),...rows].join('\n');
        const blob=new Blob([csvContent],{type:'text/csv;charset=utf-8;'});
        const url=URL.createObjectURL(blob);
        const link=document.createElement('a');
        link.setAttribute('href',url);
        link.setAttribute('download','rotm_votes_export_'+new Date().toISOString().slice(0,10)+'.csv');
        link.style.visibility='hidden';
        document.body.appendChild(link); link.click(); document.body.removeChild(link);
        alert("Votes exported successfully to CSV.");
    });

    // --- UPDATED: Replace old videos completely ---
    async function updateVideosFromJSON() {
        if (!confirm("This will replace ALL videos in Firestore with those from links.json. Continue?")) return;

        try {
            const response = await fetch('links.json');
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const redditUrls = await response.json();

            const videoDataList = [];
            const promises = redditUrls.map(async (url) => {
                try {
                    const r = await fetch(url + ".json");
                    const j = await r.json();
                    const data = j[0].data.children[0].data;
                    const title = data.title || "Untitled Post";
                    const upvotes = data.score || 0;
                    const match = url.match(/\/comments\/([a-z0-9]+)\//);
                    const id = match ? match[1] : null;
                    if (id) videoDataList.push({ id, title, upvotes, redditUrl: url });
                } catch (err) {
                    console.error(`Failed to fetch Reddit data for ${url}`, err);
                }
            });

            await Promise.allSettled(promises);
            if (videoDataList.length === 0) {
                alert("No valid videos found in links.json.");
                return;
            }

            // Delete old videos first
            const videosRef = collection(db, "videos");
            const existing = await getDocs(videosRef);
            const batchSize = 500;

            const chunk = (arr, size) => {
                const out = [];
                for (let i = 0; i < arr.length; i += size) out.push(arr.slice(i, i + size));
                return out;
            };

            const toDelete = existing.docs.map(d => d.id);
            let deletedCount = 0;
            for (const chunkSet of chunk(toDelete, batchSize)) {
                const batch = writeBatch(db);
                chunkSet.forEach(id => batch.delete(doc(db, "videos", id)));
                await batch.commit();
                deletedCount += chunkSet.length;
            }

            // Write new videos
            let writtenCount = 0;
            for (const chunkSet of chunk(videoDataList, batchSize)) {
                const batch = writeBatch(db);
                chunkSet.forEach(v => batch.set(doc(db, "videos", v.id), v));
                await batch.commit();
                writtenCount += chunkSet.length;
            }

            alert(`Updated Firestore: deleted ${deletedCount} old videos, added ${writtenCount} new ones.`);
        } catch (e) {
            console.error("Error updating videos:", e);
            alert("Failed to update videos. Check console for details.");
        }
    }
}
</script>
</body>
</html>
